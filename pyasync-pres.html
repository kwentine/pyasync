<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Programmation asynchrone en Python</title>
<meta name="author" content="(Quentin Agren)"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="http://cdn.jsdelivr.net/reveal.js/3.0.0/css/reveal.css"/>

<link rel="stylesheet" href="http://cdn.jsdelivr.net/reveal.js/3.0.0/css/theme/moon.css" id="theme"/>


<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = 'http://cdn.jsdelivr.net/reveal.js/3.0.0/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide"><h1 class="title">Programmation asynchrone en Python</h1><h2 class="date">20/10/2017</h2>
</section>
<section id="table-of-contents">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#/slide-org9a36153">Programme</a></li>
<li><a href="#/slide-org89b29af">Caclcul des nombres de Fibonacci</a></li>
<li><a href="#/slide-orgbaed375">Le serveur ses clients</a></li>
<li><a href="#/slide-org10d69c1">Limitations du synchrone</a></li>
<li><a href="#/slide-org06808f9">Threads</a></li>
<li><a href="#/slide-org69bedb7">Callbacks</a></li>
<li><a href="#/slide-orgeeec835">Coroutines</a></li>
<li><a href="#/slide-org88ed551">Coroutines avec threads</a></li>
<li><a href="#/slide-orgbd070a2">Asyncio</a></li>
<li><a href="#/slide-org938183b">Tornado</a></li>
<li><a href="#/slide-org1b3f1cd">Conclusion</a></li>
</ul>
</div>
</div>
</section>
<section>
<section id="slide-org9a36153">
<h2 id="org9a36153">Programme</h2>
<ul>
<li>Implémenter un serveur qui calcule les nombres de Fibonacci</li>
<li>Version synchrone
<ul>
<li>Limites</li>

</ul></li>
<li>Différentes versions asynchrones
<ul>
<li>Threads</li>
<li>Callbacks</li>
<li>Boucle événementielle et coroutines</li>
<li>Utilisation d'asyncio</li>

</ul></li>

</ul>

</section>
</section>
<section>
<section id="slide-org89b29af">
<h2 id="org89b29af">Caclcul des nombres de Fibonacci</h2>
<ul>
<li>Algorithme récursif</li>

</ul>
<div class="org-src-container">

<pre  class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">fib</span>(n):
    <span style="color: #CC9393;">"""Compute n-th Fibonacci number"""</span>
    <span style="color: #F0DFAF; font-weight: bold;">if</span> n &lt;= 1: <span style="color: #F0DFAF; font-weight: bold;">return</span> n
    <span style="color: #F0DFAF; font-weight: bold;">else</span>: <span style="color: #F0DFAF; font-weight: bold;">return</span> fib(n-1) + fib(n-2)
</pre>
</div>
<ul>
<li>La suite croît très vite
<ul>
<li>\(Fib(30) = 832 040\)</li>
<li>\(Fib(40) = 102 334 155\)</li>

</ul></li>
<li>Le calcul devient rapidement coûteux
<ul>
<li>permettra de simuler des requêtes gourmandes en CPU</li>

</ul></li>

</ul>
</section>
</section>
<section>
<section id="slide-org5418801">
<h3 id="org5418801">Pour Baptiste</h3>
<ul>
<li>Une version plus efficace en LISP</li>

</ul>
<div class="org-src-container">

<pre  class="src src-elisp">(<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">fib</span> (n)
  <span style="color: #9FC59F;">"Compute n-th Fibonacci number iteratively"</span>
    (<span style="color: #F0DFAF; font-weight: bold;">defun</span> <span style="color: #93E0E3;">fib-iter</span> (a b n)
        (<span style="color: #F0DFAF; font-weight: bold;">if</span> (= n 0)
            a
          (fib-iter b (+ b a) (- n 1))))
  (fib-iter 0 1 n))

(fib 10) <span style="color: #5F7F5F;">;; </span><span style="color: #7F9F7F;">returns 55</span>
</pre>
</div>
</section>
</section>
<section>
<section id="slide-orgbaed375">
<h2 id="orgbaed375">Le serveur ses clients</h2>
<div class="outline-text-2" id="text-orgbaed375">
</div>
</section>
</section>
<section>
<section id="slide-org6c0367c">
<h3 id="org6c0367c">Serveur synchrone</h3>
<ul>
<li>Accepte les connexions TCP</li>
<li>Attend du client connecté un entier \(n\)</li>
<li>Calcule puis renvoie \(fib(n)\)</li>
<li>Attend un entier etc&#x2026;</li>

</ul>
<p>
La fermeture de la connexion est à l'initiative du client.
Code : <code>fibservsync.py</code>
</p>
</section>
</section>
<section>
<section id="slide-org701dbd4">
<h3 id="org701dbd4">Clients : le frénétique et l'exigeant</h3>
<p>
Client rapide 
</p>
<ul>
<li>requêtes fréquentes et peu coûteuses</li>
<li>combien de requêtes/seconde supporte notre serveur ?</li>

</ul>
<p>
Client lent
</p>
<ul>
<li>requêtes coûteuses en calcul (35ème nombre de Fibonacci)</li>
<li>combien de temps le serveur met-il à répondre ?</li>

</ul>

<p>
<i>Idée : Utiliser différentes combinaisons de ces clients pour évaluer
les performances du serveur</i>
</p>

<p>
Code
</p>
<ul>
<li><code>fibclientslow.py</code></li>
<li><code>fibclientfast.py</code></li>

</ul>

</section>
</section>
<section>
<section id="slide-orgd5efb19">
<h3 id="orgd5efb19">Démo</h3>
</section>
</section>
<section>
<section id="slide-org10d69c1">
<h2 id="org10d69c1">Limitations du synchrone</h2>
<p>
Et les alternatives qu'on va explorer
<a href="./img/sync-async.png">illustration</a>
</p>
</section>
</section>
<section>
<section id="slide-org06808f9">
<h2 id="org06808f9">Threads</h2>
<ul>
<li>Idée : créer un thread par connexion entrante</li>

</ul>
<div class="org-src-container">

<pre  class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">run_server</span>(host=<span style="color: #CC9393;">'127.0.0.1'</span>, port=5000):
    <span style="color: #DFAF8F;">s</span> = socket.socket()
    <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">...</span>
    s.listen(5)
    <span style="color: #F0DFAF; font-weight: bold;">while</span> <span style="color: #BFEBBF;">True</span>:
        <span style="color: #DFAF8F;">conn</span>, <span style="color: #DFAF8F;">addr</span> = s.accept() <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Blocking</span>
        <span style="color: #F0DFAF; font-weight: bold;">print</span>(<span style="color: #CC9393;">'Connection from {}.'</span>.<span style="color: #DCDCCC; font-weight: bold;">format</span>(addr))
        <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Handle client in a separate thread, </span>
        <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">and go back to listening.</span>
        Thread(target=handle_client, args=(conn,)).start() 
</pre>
</div>
<ul>
<li>Avantage : permet de servir plusieurs client à la fois</li>
<li>Inconvénients : coûteux en ressources
<ul>
<li>L'OS ne peux pas créer un nombre illimité de threads</li>

</ul></li>

</ul>
</section>
</section>
<section>
<section id="slide-org1d4e99e">
<h3 id="org1d4e99e">Observations</h3>
<ul>
<li>Client rapide : moins de req/sec
<ul>
<li>coût de la création des threads</li>

</ul></li>
<li>Deux clients rapides : req/sec divisé par deux</li>
<li>Rapide + lent 
<ul>
<li>req/sec chute drastiquement</li>
<li>client lent inaffecté</li>

</ul></li>
<li>Rapide + rapide
<ul>
<li>Requêtes deux fois plus lentes</li>

</ul></li>
<li>GIL
<ul>
<li>Un thread s'exécute à la fois dans l'interpréteur</li>
<li>priorité donnée au thread gourmand en CPU</li>

</ul></li>

</ul>

</section>
</section>
<section>
<section id="slide-org69bedb7">
<h2 id="org69bedb7">Callbacks</h2>
<ul>
<li>Idée : demander au système d'exploitation de prévenir quand des
événements arrivent du réseau</li>
<li>Lier des callbacks aux événements</li>

</ul>

</section>
</section>
<section>
<section id="slide-org1b8270e">
<h3 id="org1b8270e">Selecteurs</h3>
<p>
(illustration sélecteur)
</p>
<ul>
<li>selectors.DefaultSelector</li>

</ul>

</section>
</section>
<section>
<section id="slide-org3ac9c29">
<h3 id="org3ac9c29">Boucle événementielle</h3>

</section>
</section>
<section>
<section id="slide-org14f108e">
<h3 id="org14f108e">Implémentation</h3>

</section>
</section>
<section>
<section id="slide-org1431ce2">
<h3 id="org1431ce2">Observations</h3>
<ul>
<li></li>

</ul>
</section>
</section>
<section>
<section id="slide-orgeeec835">
<h2 id="orgeeec835">Coroutines</h2>
<ul>
<li>Threads : 'preemptive multitasking'
<ul>
<li>compétition entre les threads</li>
<li>OS décide des changements de contexte</li>

</ul></li>
<li>Coroutines : 'cooperative multitasking'
<ul>
<li>coopération entre les tâches</li>
<li>changements de contexte explicites
<ul>
<li>"je choisis de suspendre mon exécution quand je dois attendre de l'I/O"</li>

</ul></li>

</ul></li>

</ul>
</section>
</section>
<section>
<section id="slide-orgd7d1bb4">
<h3 id="orgd7d1bb4">Le principe</h3>
<ul>
<li>fonction capable de suspendre temporairement son exécution</li>
<li>mot clé `yield` : [définition]</li>
<li>exemple de coroutine</li>

</ul>
<div class="org-src-container">

<pre  class="src src-python">
</pre>
</div>
</section>
</section>
<section>
<section id="slide-org7f5acb9">
<h3 id="org7f5acb9">Exécution coopérative d'une liste de tâches</h3>
<ul>
<li>une queue contient les tâches en cours</li>
<li>un ordonnanceur (<i>scheduler</i>) les avance tour à tour</li>

</ul>
<div class="org-src-container">

<pre  class="src src-python">-<span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">run_until_complete</span>(tasks):
    <span style="color: #F0DFAF; font-weight: bold;">while</span> tasks:
        <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Fetch next task from the beginning of the queue</span>
        <span style="color: #DFAF8F;">coro</span> = tasks.popleft()
        <span style="color: #F0DFAF; font-weight: bold;">try</span>:
            <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Advance task one step, until next 'yield'</span>
            <span style="color: #DCDCCC; font-weight: bold;">next</span>(coro)
        <span style="color: #F0DFAF; font-weight: bold;">except</span> <span style="color: #7CB8BB;">StopIteration</span> <span style="color: #F0DFAF; font-weight: bold;">as</span> exc:
            <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">The task finished, and its return value is </span>
            <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">retrieved from the exception.</span>
            <span style="color: #F0DFAF; font-weight: bold;">print</span>(<span style="color: #CC9393;">'Scheduler: task returned'</span>, exc.value)
            <span style="color: #F0DFAF; font-weight: bold;">continue</span>
        <span style="color: #F0DFAF; font-weight: bold;">else</span>:
            <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Put the task back at the end of the queue</span>
            tasks.append(coro)
</pre>
</div>
</section>
</section>
<section>
<section id="slide-orgaa945b7">
<h3 id="orgaa945b7">Application à Fibserver</h3>
<p>
La boucle événementielle (<i>event loop</i>) :
</p>
<ol>
<li>dépile les tâches, les fait avancer</li>
<li>les met en attente dans le sélecteur</li>
<li>les rempile quand les sockets sont prêtes</li>

</ol>
<p>
<a href="img/event-loop.png">Illustration</a>
<img src="./img/event-loop.png" alt="event-loop.png" />
</p>
</section>
</section>
<section>
<section id="slide-org88ed551">
<h2 id="org88ed551">Coroutines avec threads</h2>
<ul>
<li>Idée : déléguer uniquement les calculs qui bloquent la boucle à des Threads</li>

</ul>
</section>
</section>
<section>
<section id="slide-orgbd070a2">
<h2 id="orgbd070a2">Asyncio</h2>
</section>
</section>
<section>
<section id="slide-org938183b">
<h2 id="org938183b">Tornado</h2>
</section>
</section>
<section>
<section id="slide-org1b3f1cd">
<h2 id="org1b3f1cd">Conclusion</h2>
<p>
Pas le temps, il faut <b>vraiment</b> que j'aille me coucher&#x2026;
</p>
</section>
</section>
</div>
</div>
<script src="http://cdn.jsdelivr.net/reveal.js/3.0.0/lib/js/head.min.js"></script>
<script src="http://cdn.jsdelivr.net/reveal.js/3.0.0/js/reveal.js"></script>

<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: false,
center: true,
slideNumber: 'c',
rollingLinks: true,
keyboard: true,
overview: true,
width: 1200,
height: 800,
margin: 0.10,

theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
transition: Reveal.getQueryHash().transition || 'cube', // default/cube/page/concave/zoom/linear/fade/none
transitionSpeed: 'default',
multiplex: {
    secret: '', // null if client
    id: '', // id, obtained from socket.io server
    url: '' // Location of socket.io server
},

// Optional libraries used to extend on reveal.js
dependencies: [
 { src: 'http://cdn.jsdelivr.net/reveal.js/3.0.0/lib/js/classList.js', condition: function() { return !document.body.classList; } },
 { src: 'http://cdn.jsdelivr.net/reveal.js/3.0.0/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: 'http://cdn.jsdelivr.net/reveal.js/3.0.0/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: 'http://cdn.jsdelivr.net/reveal.js/3.0.0/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
 { src: 'http://cdn.jsdelivr.net/reveal.js/3.0.0/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }]
});
</script>
</body>
</html>
